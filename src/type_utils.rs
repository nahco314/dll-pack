/// Enumerates function signatures with an increasing number of arguments (from 0 to 16).
///
/// For each arity, it calls the passed-in macro (`$mac`) with a set of argument identifiers.
/// This allows us to programmatically generate repeated implementations for each signature.
macro_rules! for_each_function_signature {
    ($mac:ident) => {
        // no-argument function
        $mac!(0);

        // function with 1 argument
        $mac!(1 A1);

        // function with 2 arguments
        $mac!(2 A1 A2);

        // ...and so on, up to 16 arguments
        $mac!(3 A1 A2 A3);
        $mac!(4 A1 A2 A3 A4);
        $mac!(5 A1 A2 A3 A4 A5);
        $mac!(6 A1 A2 A3 A4 A5 A6);
        $mac!(7 A1 A2 A3 A4 A5 A6 A7);
        $mac!(8 A1 A2 A3 A4 A5 A6 A7 A8);
        $mac!(9 A1 A2 A3 A4 A5 A6 A7 A8 A9);
        $mac!(10 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10);
        $mac!(11 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11);
        $mac!(12 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12);
        $mac!(13 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13);
        $mac!(14 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14);
        $mac!(15 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15);
        $mac!(16 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15 A16);
    };
}

/// A helper trait that unifies a tuple of arguments `(Args, ...)` and a return type into
/// a *specific* function pointer type.
///
/// This is particularly useful for bridging "call" signatures to `extern "C"` or `extern "system"`
/// function pointers. We use it in combination with [`Caller`] to dispatch calls with
/// the correct signature.
pub trait IOToFn {
    /// The resulting function pointer type after applying the transformation.
    type Output;
}

/// Implements [`IOToFn`] for varying function signatures.
///
/// The macro receives two patterns:
/// - `$num:tt $arg:ident` for single-argument functions.
/// - `$num:tt $($args:ident)*` for multi-argument functions.
///
/// For each pattern, it creates an `impl IOToFn for ((args...), Res)` which resolves into
/// a function pointer of the form `unsafe extern "C" fn(args...) -> Res`.
macro_rules! impl_io_to_fn {
    // single argument version
    ($num:tt $arg:ident) => {
        #[allow(non_snake_case)]
        impl<$arg, Res> IOToFn for (($arg,), Res)
        {
            type Output = unsafe extern "C" fn($arg) -> Res;
        }
    };

    // multi-argument version
    ($num:tt $($args:ident)*) => {
        #[allow(non_snake_case)]
        impl<$($args,)* Res> IOToFn for (($($args,)*), Res)
        {
            type Output = unsafe extern "C" fn($($args),*) -> Res;
        }
    }
}

// Generate implementations of IOToFn for each function arity (0..16).
for_each_function_signature!(impl_io_to_fn);

/// A trait defining how to *call* a function pointer that was generated by [`IOToFn`].
///
/// The trait is implemented over a tuple `Args` and a result type `Res`, and references
/// the function pointer type from `(Args, Res) as IOToFn`.
///
/// This allows uniform invocation of different-arity native function pointers in a type-safe way.
pub trait Caller<Args, Res>
where
    (Args, Res): IOToFn,
{
    /// Calls the function pointer `func` with the given `input` arguments, returning `Res`.
    fn call(input: Args, func: &<(Args, Res) as IOToFn>::Output) -> Res;
}

/// Implements [`Caller`] for varying function signatures.
///
/// Similar to `impl_io_to_fn`, we generate the actual call logic for 1..16 arguments.
/// - `$num:tt $arg:ident` handles single-argument calls.
/// - `$num:tt $($args:ident)*` handles multi-argument calls.
///
/// Each implementation performs an unsafe call to the `extern "C"` function pointer.
macro_rules! impl_caller {
    // single argument version
    ($num:tt $arg:ident) => {
        #[allow(non_snake_case)]
        impl<$arg, Res> Caller<($arg,), Res> for ($arg,)
        {
            fn call(($arg,): ($arg,), func: &unsafe extern "C" fn($arg) -> Res) -> Res {
                // safety: the function pointer must be valid and follow the correct ABI
                unsafe { func($arg) }
            }
        }
    };

    // multi-argument version
    ($num:tt $($args:ident)*) => {
        #[allow(non_snake_case)]
        impl<$($args,)* Res> Caller<($($args,)*), Res> for ($($args,)*)
        {
            fn call(($($args,)*): ($($args,)*), func: &unsafe extern "C" fn($($args),*) -> Res) -> Res {
                // safety: the function pointer must be valid and follow the correct ABI
                unsafe { func($($args),*) }
            }
        }
    }
}

// Generate implementations of Caller for each function arity (0..16).
for_each_function_signature!(impl_caller);
